## [평범한 배낭](https://www.acmicpc.net/problem/12865)
* 소요 시간 : 약 1시간 30분 (풀이 30분, 오류 1시간)
- 오류  : 런타임 에러(segfault)
- 오류 원인 : initDP 등 배열 자료구조를 잘못 이용한 것으로 추정. (최종 result 할당 및 출력 시 err) 
- 해결 : 고정길이배열로 변경 후 해결

### 실패코드
```cpp
#define loop(i,a,b) for (int i = (a); i < (b); i++)

#include <iostream>
using namespace std;

int**& initArr(int N) {
	int** arr = new int*[N+1];
	loop(i, 1, N+1) {
		arr[i] = new int[2];
		cin >> arr[i][0]>>arr[i][1];
	}
	return arr;
}
int**& initDP(int N,int K) {
	int** dp = new int*[N+1];
	loop(i, 0, N+1) {
		dp[i] = new int[K+1];
		loop(j, 0, K + 1) { dp[i][j] = 0; }
	}
	return dp;
}

int main(void)
{
	int N;
	int K;
	cin >> N >> K;
	int** stuffs = initArr(N); //[0] : W / [1] : V
	int** dp = initDP(N+1, K+1);
	loop(i, 1, N + 1) {
		loop(j, 1, K + 1) {
			dp[i][j] = dp[i-1][j];
			if (stuffs[i][0] <= j) {
				int pre = dp[i][j];
				int next = dp[i - 1][j - stuffs[i][0]] + stuffs[i][1];
				dp[i][j] = (pre > next) ? pre : next;
			}
		}
	}

	int result = dp[N][K];
	cout << result <<endl;
	return 0;
}

```


### 성공 코드
```cpp
#define loop(i,a,b) for (int i = (a); i < (b); i++)

#include <iostream>
using namespace std;

int**& initArr(int N) {
	int** arr = new int*[N+1];
	arr[0] = new int[2]; arr[0][0] = 0; arr[0][1] = 0;
	loop(i, 1, N+1) {
		arr[i] = new int[2];
		cin >> arr[i][0]>>arr[i][1];
	}
	return arr;
}
int**& initDP(int N,int K) {
	int** dp = new int*[N+1];
	loop(i, 0, N+1) {
		dp[i] = new int[K+1];
		loop(j, 0, K + 1) { dp[i][j] = 0; }
	}
	return dp;
}

int main(void)
{
	int N;
	int K;
	cin >> N >> K;
  int w[100001]={0,};
  int v[1001]={0,};
  loop(i,1,N+1){cin>>w[i]>>v[i];}
	int dp[105][100005]={0,};
	loop(i, 1, N + 1) {
		loop(j, 1, K + 1) {
			if (w[i] <= j) {
				int pre = dp[i-1][j];
				int next = dp[i - 1][j - w[i]] + v[i];
				dp[i][j] = (pre > next) ? pre : next;
			}else{
                dp[i][j]=dp[i-1][j];
            }
		}
	}

	int result = dp[N][K];
	cout << result <<endl;
	return 0;
}

```

----------------------------------------------------------------------------
### comment 

* segmentation fault :
	올바르지 않은 메모리 접근 시, 허용되지 않은 메모리 영역에 접근 시 발생.

-> null값을 가리키는 포인터에 접근하는 경우
-> read-only로 표시된 메모리 영역에 쓰려고 할 때
-> 더 이상 존재하지 않는 메모리 영역을 가리킬 때

* 코드 리뷰
백준 통과는O, 에러해결은X
:백준 질문글에 올라와있는 반례는 통과.
엣지케이스(1,1) 통과.
-> 엣지케이스(100,100000) 확인해보기.
```cpp
#define loop(i,a,b) for (int i = (a); i < (b); i++) // loop : a ~ b-1

int**& initArr(int N) { // N=100일경우,
	int** arr = new int*[N+1]; //0-100
	arr[0] = new int[2]; arr[0][0] = 0; arr[0][1] = 0;
	loop(i, 1, N+1) { //1-100
		arr[i] = new int[2];
		cin >> arr[i][0]>>arr[i][1];
	}
	return arr; //arr[0]~arr[100]
}

int**& initDP(int N,int K) { //N,K = 100,100000일경우, 
	int** dp = new int*[N+1]; //dp[0]~dp[100]
	loop(i, 0, N+1) { //dp[0]~dp[100]
		dp[i] = new int[K+1]; // dp[0-100][0-100000]
		loop(j, 0, K + 1) { dp[i][j] = 0; } //dp[0-100][0-100000] : 0으로 초기화
	}
	return dp; -> //N,K = 100,100000일경우, dp[0-100][0-100000] 반환
}

int main(void)
{
	int N=100;
	int K=100000;
	int** stuffs = initArr(N); //[0] : W / [1] : V //arr[0-100]
	int** dp = initDP(N+1, K+1); //dp[0-101][0-100001]
	loop(i, 1, N + 1) { // 1-100
		loop(j, 1, K + 1) { //1-100000
			dp[i][j] = dp[i-1][j]; //[1][1] = [0][1] ~ [100][100000] = [99][100000]
			if (stuffs[i][0] <= j) {
				int pre = dp[i][j]; //dp [1][1] ~ [100][100000]
				int next = dp[i - 1][j - stuffs[i][0]] + stuffs[i][1]; //dp [0][0] ~ [100][100000] // stuffs[1~100] // stuffs[i][0] <= j이므로 음수인덱스x  
				dp[i][j] = (pre > next) ? pre : next; 
			}
		}
	}

	int result = dp[N][K]; // dp[0][0]~dp[100][100000]
	cout << result <<endl;
	return 0;
}

```
인덱스만 고려해봤을 때에는 문제가 발생하지 않아야하지만 segfault발생중. 
dp배열만 고정길이 배열로 바꾸고, result 출력 x시 segfault 발생x, (틀렸습니다) => 값이 잘못 들어가 결과값에서 null 접근 등의 오류로 추정
현재 백준 통과 정답에서 배열만 고정길이에서 동적할당으로 변경 시 segfault 발생 => 값이 들어가는 로직 자체는 문제가 없는 것으로 추정
==>원인 파악 현재 x
