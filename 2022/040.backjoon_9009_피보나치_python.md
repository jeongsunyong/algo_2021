
## [피보나치](https://www.acmicpc.net/problem/9009)
* 소요 시간 : 20분

### 성공 코드
```python
import sys

T=int(input())

f=[0,1]
for i in range(2,1000000):
  f.append(f[i-1]+f[i-2])
  if f[i]>1000000000:
    break
for i in range(T):
  n=int(sys.stdin.readline().rstrip())
  num=n
  f_sum=[]
  while num>0:
    pre=0
    for j in f:
      if num<j:
        num-=pre
        f_sum.append(pre)
        break
      pre=j
  f_sum.reverse()
  print(" ".join(map(str,f_sum)))
      
     
"""
GOAL 피보나치 수들 합이 주어진 정수와 같게되는 최소개수 서로다른 피보나치수
"""
```



----------------------------------------------------------------------------
### comment 
      
2/27 코드리뷰  
정수가 주어졌을 때 피보나치수의 덧셈조합으로 표현 (최소개수) 문제.    
접근은 순회로 불가능, 경우의수를 다 세는 것도 시간복잡도가 무조건 초과된다고 생각이들어    
원리를 찾거나 아이디어를적용해야하는문제로 접근    
우선 이런문제같은경우에는 큰 수부터 더하는 것이 보통 최소 개수를 맞추기 위한 조건인데       
이 때 가장 큰 수가 해당 수 n을 이루기 위한 조합에 무조건 들어가는지 판단하는게 어려웠음.        
일단 큰 남은 수들을 더하는 방향으로 제출했는데 통과.      
설계나 원리를 안다기보다는 얼결에 통과.     
=> 풀이를 보니, 피보나치수의 성격상 f3 =f1 + f2이고,   
f1과 f2를 사용하지 않는다면 그 아래 모든 수의 합들이 만드려는 수보다 작다.
왜냐하면 피보나치수의 의미 자체가 그 이전까지의 수를 더한것이므로 ( f1 < 1/2 * f3 )
```python
ex) 
1 1 2 sum 4
1 1 2 3 sum 7
1 1 2 3 5 sum 12
1 1 2 3 5 8 sum 20
1 1 2 3 5 8 13 sum 33
1 1 2 3 5 8 13 21 sum 54
1 1 2 3 5 8 13 21 34 sum 88
.
.

```
f1는 항상 f2보다 작고, 최소개수로 f3를 만들기 위해서는 f2가 필수적으로 필요하다.   
이 때, 내가 바로 이해가 안된 부분은 f2와 어떤 수의 조합으로 반드시 f3를 만들 수 있는가였는데,   
f3자체가 피보나치수(이전수들의합)으로 이루어진수, f2또한 마찬가지이므로 반드시 존재한다.(1의 합으로 만들어진 수가 모든 자연수이고 자연수의 조합으로 모든 수를 만들 수 있는것과 동일   


#
#
 ### learned lesson
 
* **fibonacci    
#
#
 
 
 
 
 

