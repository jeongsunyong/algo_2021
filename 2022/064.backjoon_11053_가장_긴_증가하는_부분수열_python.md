
## [가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)
* 소요 시간 :  1시간 30분

### 성공 코드
```python
from collections import deque
n=int(input())
A=list(map(int,input().rstrip().split(" ")))
dp=[1]*(n) # i까지 가장 긴 증가하는 부분 수열 길이
for i in range(n):#0~n-1까지 숫자들 loop
    for j in range(i):# 0~i-1까지 비교.
        if A[i]>A[j]: #이전에 존재하는 숫자가 더 작다면,
            dp[i]=max(dp[i],dp[j]+1) #해당 숫자에서 현재 숫자를 더한게 개수가 큰지, 현재숫자까지 개수 큰지 판정 후 값 갱신.
   
print(max(dp))
```



----------------------------------------------------------------------------
### comment 
3/23 코드리뷰
이전 [전깃줄](https://github.com/jeongsunyong/algo_2021-2022/blob/main/2022/060.backjoon_2565_%EC%A0%84%EA%B9%83%EC%A4%84_python.md) 문제와 동일 유형의 문제.  
LIS Longest Increasing Subsequence문제로, 이름이 있을 정도로 유명한 문제인듯 하고 당시 풀지 못해서 위 문제를 풀어보고자 해서 풀이함.   

1차접근   
```python
selected=deque([]) #선택된 것 개수.
selected.append([A[0],0])
for i in range(1,len(A)): #기본코드
    if selected[-1][0]<A[i]:
        selected.append([A[i],i])
        cnt+=1
    while selected[-1][0]>A[i]: #경우의 수 비교, 뒤에 나올 수 있는 값들이 더 크면 변경해줌 ###### LOOP A
        cnt_aft1=0
        cnt_aft2=0
        for j in range(selected[-1][1],n):
```
바로 떠오르지 않아서 일단 그냥 손이 가는대로 위와같이 queue에 최대 길이를 갖는 값들을 갱신하면서(stack) 찾으려고 하였으나,  
위와 같이라는것은 수열을 순회하면서 기준값보다 크다면 stack에 넣고, 
마지막 선택된 원소보다 작은 수가 나타나면 마지막 선택된 원소와 작은 수를 비교하여 앞으로 더 큰 개수를 갖는 원소가 해당 자리를 차지하게 하는 방법.  
그러나 LOOP A에서 O(n)loop로 어떤 원소가 더 큰 연속수열을 갖는지 알 수 없었다.    
또한 DP는 이전 정보들을 이용하는게 핵심이었는데 이전정보를 하나도 이용하지 않아 해당풀이에서 발전시킨다 해도 시간복잡도가 클 것으로 예상되었음 (DP 유형이라는 것을 알고있었기에 이렇게 생각함)   

일단 생각이 잘 안나서 단순화시킴   
```python
for i in range(1,n):
    if A[i]>A[i-1]:
        conseq[i]=conseq[i-1]+1 #dp
    elif A[i]==A[i-1]:
        conseq[i]=conseq[i] #dp
    elif A[i]<A[i-1]:
        conseq[i]=1 #dp
        # conseq[i]는 A[0]~A[i-1]까지 중 A[i]보다는 작은 A[x]에 대해 가장 큰 값 +1. 아니면 그냥 1.
```
연속되는 개수를 저장.   
이 때 conseq는 해당 숫자까지 연속 수열 개수이다.   
이 값이 최대인지? 아님.   
왜 아닌지? : ->
```
dp : 숫자 저장 or 가능한 max  count저장
    가능한 max_count저장 시
    dp값의미?: 해당 원소 선택 or 해당원소까지의 최대count
    전개
        (1)dp[0]= 원소선택 10, 원소까지 카운트는 1
        (2)dp[1]= 원소선택 20, 원소까지 카운트는 2
            * 판정 기준 : 10보다 큰 수 20. 카운트 증가
        (3)dp[2]= 원소선택 10, 원소까지 카운트는 2
            *판정 기준: 20보다 작은 수 10, 이전 수 10보다 크지 않으므로 선택 시 카운트 1이므로 -> 기존 (2) 유지.
        (4)dp[3]= 원소선택 30, 원소까지 카운트는 3
            *판정 기준 : 20보다 큰 수 30, 카운트 증가
        (5)dp[4]= 원소선택 20, 원소까지 카운트는 3
            * 판정 기준  : 30보다 작은 수 20, 20 선택 시 이전 수 20보다 크지 않음, 10보다는 큼 카운트2-> 기존 (3) 유지
        (6)dp[5]= 원소선택 50, 원소까지 카운트는 4
            * 판정 기준 : 30보다 큰 수 50, 카운트 증가
        
        -> 문제 케이스 : 이 방법의 문제점은 20,30,50선택하고 25,26,27이 남았으면 25이후는 무시당하는 숫자가 됨.
            -> 뒤에 뭐가 나올지 알 수 없다.
            -> 앞을 보고 정보를 활용해서 최대가 되는 값을 선택해야함.
            
```
-> 각 루프에서 앞의 원소들을 검사, 자기 자신보다 더 작은 값으로 끝나는 수열과 붙었을 경우 가장 큰 길이를 채택해준다.   
또 마지막에는 dp[n-1]이 아닌 max(dp)를 출력해줘야함(어떤것으로 끝나는 것이 가장 큰지 모르므로.   
-> 통과 

#
#
 ### learned lesson
 
* ** dp
* ** LIS
> [LIS 블로그 글(백준11053)](https://seohyun0120.tistory.com/entry/%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4LIS-%EC%99%84%EC%A0%84-%EC%A0%95%EB%B3%B5-%EB%B0%B1%EC%A4%80-%ED%8C%8C%EC%9D%B4%EC%8D%AC)
> 다음 풀어볼 문제는 백준 12015, 14002, 14003 (+11053번 11055번 11722번 12015번 12738번 14002번 14003번)
#
#
 
 
 
 

