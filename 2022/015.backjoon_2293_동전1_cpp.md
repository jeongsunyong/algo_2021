
## [동전1](https://www.acmicpc.net/problem/2293)
* 소요 시간 : 약 2시간 30분

### 성공 코드
```cpp
#define loop(i,a,b) for (int i = (a); i <= (b); i++)

#include <iostream>
#include <vector>
using namespace std;

int main(void) {
	int n, k;
	cin >> n >> k;
	int coins[101] = { 0 };
	int dp[10001] = { 0 }; //dp[i] : 합이 i가 되는 경우의수
	loop(i, 0, n-1) {
		cin >> coins[i];
	}
	dp[0] = 1;
	loop(i, 0, n-1) {
		loop(j, coins[i], k) { 
			dp[j] += dp[j - coins[i]];
		}
	}

	cout << dp[k] << endl;


	return 0;
}

/* note

goal : 가치의 합이 k원이 되도록 하는 그 경우의 수
rule :
	1.각 동전은 몇 번이든 사용할 수 있다.
	2. 순서만 다른 경우는 같은경우이다.


	coins => 1,2,5 
	1 : 1
	2를 만드는 방법 : 2: 2  / 1 1
	3을 만드는 방법 : 2 :  1 1 + 1  / 2 + 1    => dp[i-1]
	4를 만드는 방법 : 3 :  1 1 1 + 1 / 2 1 + 1 / ***  2 2 => dp[i-1] + 1개
	if 5
	4 : 1 1 1 1 1 / 2 1 1 1 / 2 2 1 / *** 5  ==> dp[i-1] + 1개
	if 6
	5 : 1 1 1 1 1 1 / 2 1 1 1 1 / 2 2 1 1 / 5 1 / *** 2 2 2 ==> dp[i-1] + 1개
	if 7
	6 : 1 1 1 1 1 1 1 / 2 1 1 1 1 1 / 2 2 1 1 1 / 5 1 1 / 2 2 2 1 / *** 5 2
	if 8
	7 : 1 1 1 1 1 1 1 1 / 2 1 1 1 1 1 1 1 / 2 2 1 1 1 1 / 5 1 1 1 / 2 2 2 1 1 / 5 2 1 /
		**** 2 2 2 2
	if 9
	8 : 1 1 1 1 1 1 1 1 1 / 2 1 1 1 1 1 1 1 1  / 2 2 1 1 1 1 1 / 5 1 1 1 1 / 2 2 2 1 1 1 / 5 2 1 1 /
		2 2 2 2 1 / **** 5 2 2

*/
```



----------------------------------------------------------------------------
### comment 
      
2/2코드리뷰  
처음에는 쉽게 생각해서 dp 루프를
```cpp
	loop(i, 3, k) {
		dp[i] += coins[i];
		loop(j, 1, i/2) { 
			int case_cnt= dp[j] * dp[i - j]; //if i==4 , j==1 => dp[1] * dp[3]
			dp[i] += (j == i - j) ? (case_cnt / dp[j]) : case_cnt;
		}
	}
```
위와 같이 작성했었는데, 
이럴 경우에는 
```cpp
	//dp[5] => dp[3] * dp[2]  => 1 1 1 / 1 1
	//dp[5] => cp[4] * dp[1]  => 1 1 1 1 / 1 중복count.
```
위와 같은 문제가 발생(상위 경우의수가 하위 포함).

=> 각 경우의 수에 대해서
coin[i]개를 더하는 신규케이스 카운팅 필요,
: loop를 coin[i]개에서 k까지로 설정 후, 
 coin[i]를 더하는 신규 케이스를 더해준다. (이 때, coin[i]를 더하는 케이스는 coin[i]보다 큰 값을 계산할 때만 이용되므로 내부루프의 시작점은 coins[i])
 (dp[j] :  j값의 경우의 수, j-coins[i] 해당 경우의 수에서 coin[i]만큼 모자란 수이고,
 dp[j-coins[i]]는 해당 coins[i]만큼 더한 신규 케이스에 대해 누적치로 쌓인다. (loop : coins[i]->k)

처음엔 중복케이스만 걸러내는게 까다로운 부분일 줄 알았는데,
점화식이 머리로 도출이 안되서 
생각보다 case를 어떻게 누적시킬지 생각하는게 어려웠다.
비슷한 문제가 나오면 접근을 어떻게 빠르게 할 수 있을지 , 연습 필요.




#
#
 ### learned lesson
 
* **DP
#
#
 
 
 
 
 
