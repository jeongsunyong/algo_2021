
## [동전1](https://www.acmicpc.net/problem/2293)
* 소요 시간 : 2시간

### 성공 코드
```cpp
#define loop(i,a,b) for (int i = (a); i <= (b); i++)

#include <iostream>
#include <vector>
using namespace std;

int main(void) {
	int n, k;
	cin >> n >> k;
	int coins[101] = { 0 };
	int dp[10001] = { 0 }; //dp[i] : 합이 i가 되는 경우의수
	loop(i, 0, n-1) {
		cin >> coins[i];
	}
	dp[0] = 1;
	loop(i, 0, n-1) {
		loop(j, coins[i], k) { 
			dp[j] += dp[j - coins[i]];
		}
	}

	cout << dp[k] << endl;


	return 0;
}

/* note

goal : 가치의 합이 k원이 되도록 하는 그 경우의 수
rule :
	1.각 동전은 몇 번이든 사용할 수 있다.
	2. 순서만 다른 경우는 같은경우이다.


	coins => 1,2,5 
	1 : 1
	2를 만드는 방법 : 2: 2  / 1 1
	3을 만드는 방법 : 2 :  1 1 + 1  / 2 + 1    => dp[i-1]
	4를 만드는 방법 : 3 :  1 1 1 + 1 / 2 1 + 1 / ***  2 2 => dp[i-1] + 1개
	if 5
	4 : 1 1 1 1 1 / 2 1 1 1 / 2 2 1 / *** 5  ==> dp[i-1] + 1개
	if 6
	5 : 1 1 1 1 1 1 / 2 1 1 1 1 / 2 2 1 1 / 5 1 / *** 2 2 2 ==> dp[i-1] + 1개
	if 7
	6 : 1 1 1 1 1 1 1 / 2 1 1 1 1 1 / 2 2 1 1 1 / 5 1 1 / 2 2 2 1 / *** 5 2
	if 8
	7 : 1 1 1 1 1 1 1 1 / 2 1 1 1 1 1 1 1 / 2 2 1 1 1 1 / 5 1 1 1 / 2 2 2 1 1 / 5 2 1 /
		**** 2 2 2 2
	if 9
	8 : 1 1 1 1 1 1 1 1 1 / 2 1 1 1 1 1 1 1 1  / 2 2 1 1 1 1 1 / 5 1 1 1 1 / 2 2 2 1 1 1 / 5 2 1 1 /
		2 2 2 2 1 / **** 5 2 2

*/
```



----------------------------------------------------------------------------
### comment 
      
2/2코드리뷰  
처음에는 쉽게 생각해서 dp 루프를
```cpp
	loop(i, 3, k) {
		dp[i] += coins[i];
		loop(j, 1, i/2) { 
			int case_cnt= dp[j] * dp[i - j]; //if i==4 , j==1 => dp[1] * dp[3]
			dp[i] += (j == i - j) ? (case_cnt / dp[j]) : case_cnt;
		}
	}
```
위와 같이 작성했었는데, 
이럴 경우에는 
```cpp
	//dp[5] => dp[3] * dp[2]  => 1 1 1 / 1 1
	//dp[5] => cp[4] * dp[1]  => 1 1 1 1 / 1 중복count.
```
위와 같은 문제가 발생(상위 경우의수가 하위 포함).

=> 각 경우의 수에 대해서
coin[i]개를 더하는 신규케이스 카운팅 필요,
coin[0] : 1 




#
#
 ### learned lesson
 
* **DP
#
#
 
 
 
 
 
